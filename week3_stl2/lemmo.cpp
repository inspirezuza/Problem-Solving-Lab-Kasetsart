// โจทย์:
// เล็มโม่
// 1 sec, 32 MB

// เล็มโม่เป็นสิ่งมีชีวิตที่เรียบง่าย สิ่งที่มันทำคือเดิน เดินและเดินเท่านั้น ถ้าเดินไปชนขอบ ก็จะกลับหลังหัน
// ถ้าเดินตกไปใน ช่อง ก็จะหล่นไป หล่นไป หล่นไป จนกระทั่ง ตกไปที่ขุมทรัพย์ หรือท่อระบายน้ำ
// พิจารณาแผนที่และตัวอย่างการเดินใน รูปด้านล่าง

// รูปด้านซ้ายแสดงตัวอย่างการเดินที่เล็มโม่เริ่มเดินโดยหันหัวทางขวาและลงเอยที่ขุมทรัพย์ (แสดงเป็น $)
// รูป กลางแสดงตัวอย่างการเดินที่เล็มโม่เริ่มเดินโดยหันหัวทางซ้ายและลงเอยที่ท่อระบายน้ำ (แสดงเป็น
// @) รูปสุดท้ายก็แสดง ตัวอย่างที่ลงเอยที่ขุมทรัพย์

// shell
// Copy code
// >
// ##### ### ##
// ### ##### ##
// # #### #####
// @##$########
// <
// ##### ### ##
// ### ##### ##
// # #### #####
// @##$########
// <
// ##### ### ##
// ### ##### ##
// # #### #####
// @##$########

// เล็มโม่จะเดินไปบนแผนที่ที่กว้าง W หน่วย และสูง H ชั้น ชั้นล่างสุดจะเป็นชั้นที่ 1
// เล็มโม่จะเริ่มเดินที่ชั้นบนสุด คือชั้นที่ H จนไปถึงชั้นที่ 1 ในแต่ละชั้นจะแบ่งเป็นช่อง ๆ จำนวน W ช่อง
// โดยแต่ละช่องอาจเป็นพื้นหรือเป็นรู ช่องที่เป็นรู สามารถอยู่ติดกันได้ ชั้นล่างสุด (ชั้นที่ 1)
// จะประกอบด้วยพื้น กับช่องที่ระบุว่าถ้าตกลงไปแล้วจะเป็นขุมทรัพย์ หรือท่อระบายน้ำ สำหรับแผนที่ที่กว้าง W
// หน่วย จะมีจุดเริ่มต้นของเล็มโม่ได้ W จุด แต่ละจุดสามารถเริ่มโดยหันหัวทางซ้ายหรือ ทางขวา
// เราเรียกคู่ลำดับของจุดเริ่มต้นและทิศทางเริ่มต้น ว่าสถานะเริ่มต้นของเล็มโม่ สำหรับแผนที่ที่กว้าง W
// หน่วย จำนวนสถานะเริ่มต้นทั้งหมดของเล็มโม่คือ 2W แบบ
// สังเกตว่าบางสถานะเริ่มต้นจะทำให้เล็มโม่ลงเอยที่ขุมทรัพย์
// แต่บางสถานะเริ่มต้นจะทำให้เล็มโม่ลงเอยที่ท่อ ระบายน้ำ ในตัวอย่างแผนที่ด้านบนจะมีสถานะเริ่มต้น 20
// แบบที่ทำให้เล็มโม่ได้ขุมทรัพย์ และมี 4 แบบที่ทำให้ลงท่อ ระบายน้ำ
// อย่างไรก็ตามสังเกตว่าถ้าเราเจาะช่องเพิ่มที่พื้นที่ตีกรอบในรูปด้านบนซ้าย
// เล็มโม่ไม่ว่าจะเริ่มต้นที่สถานะใดก็ จะเดินไปลงเอยที่ขุมทรัพย์ทั้งหมด

// งานของคุณ:
// อ่านแผนที่จากนั้นคำนวณว่ามีสถานะเริ่มต้นกี่สถานะที่ทำให้เล็มโม่เดินลงขุมทรัพย์
// และถ้าอนุญาตให้เจาะพื้นได้หนึ่งช่อง (ไม่เจาะก็ได้)
// จำนวนสถานะเริ่มต้นมากที่สุดที่เล็มโม่เดินลงขุมทรัพย์จะเป็นเท่าใด

// ข้อมูลนำเข้า:
// บรรทัดแรกระบุจำนวนเต็ม W และ H (1<=W<=120; 1<=H<=120) จากนั้นอีก H
// บรรทัดจะระบุข้อมูลของแผนที่ กล่าวคือ ในบรรทัดที่ 1 + I สำหรับ 1 <= I <= H จะระบุข้อมูลของชั้นที่
// H – I +1 แทนด้วยสตริงความยาว W ตัว อักษร ตัวอักษรแต่ละตัวมีความหมายดังนี้ '#' แทนพื้น, '.'
// แทนรูที่ตกไปชั้นล่าง, '$' แทนรูในชั้นล่างสุดที่ตกลงไปเป็น ขุมทรัพย์ และ '@'
// แทนรูในชั้นล่างสุดที่ตกไปเป็นท่อระบายน้ำ

// รับประกันว่าเล็มโม่เมื่อเริ่มที่ชั้นบนสุดจะเดินมาจนถึงชั้นล่างสุดได้เสมอ และที่ชั้น 1 จะมีรูอย่างน้อย 1
// รูแต่อาจ จะมีมากกว่านั้นได้(มีขุมทรัพย์ได้หลายรู, มีท่อระบายน้ำได้หลายรู)
// แต่จะมีรูเฉพาะที่ตกไปเป็นขุมทรัพย์ ($) กับท่อ ระบายน้ำ (@) เท่านั้น

// ข้อมูลส่งออก:
// มีหนึ่งบรรทัดเป็นจำนวนเต็มสองจำนวน คั่นด้วยช่องว่างหนึ่งช่อง
// จำนวนแรกแทนจำนวนสถานะเริ่มต้นที่ทำให้เล็มโม่เดินถึงขุมทรัพย์ (รูใดก็ได้)
// จำนวนที่สองแทนจำนวนที่มากที่สุดของสถานะเริ่มต้นที่เล็มโม่เดินถึงขุมทรัพย์ เมื่ออนุญาตให้
// เจาะรูที่พื้นได้หนึ่งรู (แต่จะไม่เจาะก็ได้)

// ตัวอย่าง 1
// input:
// 12 4
// #####.###.##
// ###.#####.##
// #.####.#####
// @##$########

// output:
// 20 24

// ตัวอย่าง 2
// input:
// 12 4
// #####.###.##
// ###.#####.##
// #.####.##.##
// @##$#####@##

// output:
// 0 4

// write cpp program here

#include <bits/stdc++.h>
using namespace std;

const int MAXN = 125;
const int INF = 1e9;
int dp[MAXN][MAXN][MAXN][2];
int n, m;
char a[MAXN][MAXN];

int solve(int x, int y, int z, int dir) {
    if (x < 1 || y < 1 || z > m || y > z)
        return -INF;
    if (dp[x][y][z][dir] != -1)
        return dp[x][y][z][dir];
    if (x == 1) {
        for (int i = y; i <= z; i++) {
            if (a[x][i] == '$')
                return dp[x][y][z][dir] = 1;
            if (a[x][i] == '@')
                return dp[x][y][z][dir] = 0;
        }
    }
    int &ret = dp[x][y][z][dir] = 0;
    if (dir == 0) {
        ret = max({ret, solve(x, y - 1, z, 0),
                   solve(x - 1, 1, z, 1) + (a[x][y] == '$')});
        ret = max(ret, solve(x - 1, y, z, 0) + (a[x][y] == '$'));
    } else {
        ret = max({ret, solve(x, y, z + 1, 1),
                   solve(x - 1, y, m, 0) + (a[x][z] == '$')});
        ret = max(ret, solve(x - 1, y, z, 1) + (a[x][z] == '$'));
    }
    return ret;
}

int main() {
    cin >> m >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
        }
    }
    memset(dp, -1, sizeof(dp));
    int ans = 0;
    for (int i = 1; i <= m; i++) {
        for (int j = i; j <= m; j++) {
            ans = max(ans, max(solve(n, i, j, 0), solve(n, i, j, 1)));
        }
    }
    cout << ans << endl;
    return 0;
}